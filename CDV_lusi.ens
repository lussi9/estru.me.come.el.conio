;DEFINICIÃ“N DE MACROS

    LEA:    MACRO(ra, eti) ;si es direccion
        or ra,r0,low(eti)
        or.u ra,ra,high(eti)
    ENDMACRO

    LOAD:   MACRO(ra, eti) ;si es valor
        LEA(ra,eti)
        ld ra,ra,0
    ENDMACRO

    PUSH:   MACRO(ra)
        subu r30,r30,4
        st ra,r30,0
    ENDMACRO

    POP:    MACRO(ra)
        ld ra,r30,0
        addu r30,r30,4
    ENDMACRO

    consPILA:   MACRO()
        PUSH(r1)
        PUSH(r31)
        or r31,r30,r30
    ENDMACRO

    destPILA:   MACRO()
        or r30,r31,r31
        POP(r31)
        POP(r1)
    ENDMACRO


org 0x0000010

CADENA: data "tres tristes tigres comen trigo en un trigal, el primer tigre que...\0"
CADENA2: data "0123456789\0"

CMPR: 
    data 0x0b010044, 0x10102400, 0x74004000, 0x20736572
    data 0x73697274, 0x04000274, 0x00016769, 0x6d6f6304
    data 0x00046e65, 0x206f6704, 0x75206e65, 0x61060018
    data 0x65202c6c, 0x7270206c, 0x72656d69, 0x2006000c
    data 0x2e657571, 0x00002e2e

LCAD:
    LEA (r30, 60000)
    LEA (r12, CADENA)
    PUSH (r12)
    bsr LongCad
    POP (r12)
    stop

BCAR:
    LEA (r30, 60000)
    or r12, r0, 0x0000000B
    PUSH (r12)
    or r12, r0, 0x00000002
    PUSH (r12)
    LEA (r12, CADENA)
    PUSH (r12)
    or r12, r0, 115
    PUSH (r12)
    bsr BuscaCar
    addu r30, r30, 16
    stop

BMAX:
    LEA (r30, 86004)
    LEA (r12, 0x12000)			
    PUSH(r12)
    or r12, r0, 0x0000001A		
    PUSH (r12)
    LEA (r12, CADENA2)			
    PUSH (r12)
    bsr BuscaMax
    POP (r12)
    POP (r12)
    POP (r12)
    stop

COM:
    LEA (r30, 86008)
    LEA(r12, 0x12000)
    PUSH(r12)
    LEA(r12, CADENA)
    PUSH(r12)
    bsr Comprime
    POP(r12)
    stop

DPRIME: 
    LEA (r30, 86008)
    LEA(r12, 0x12000)
    PUSH(r12)
    LEA(r12, CMPR)
    PUSH(r12)
    bsr Descomprime
    POP(r12)
    POP(r12)
    stop

VERIFI:
    LEA (r30, 86004)
    LEA(r12, 0x12000)
    PUSH(r12)
    LEA(r12, 0x12200)
    PUSH(r12)
    LEA(r12, CADENA)
    PUSH(r12)
    bsr Verifica
    POP(r12)
    stop


;Subrutina LongCad
LongCad:        
    ld r2, r30, 0           ;cadena
    xor r5, r5, r5          ;contador
BULONG:         
    ld.bu r3, r2, r5        ;carga el caracter
    cmp r4, r3, 0x00        ;comprueba si ha llegado al final
    bb1 eq, r4, FINLO
    addu r5, r5, 1          ;incrementa el contador
    br BULONG
FINLO:          
    or r29, r5, 0           ;carga el resultado en r29
    jmp(r1)


;Subrutina BuscarCar
BuscaCar:       
    PUSH(r1)
    ld r2, r30, 4           ;caracter q se busca
    ld r3, r30, 8           ;cadena en la q se busca
    ld r4, r30, 12          ;posicion inicial
    ld r5, r30, 16          ;posicion final
    or r6, r4, 0            ;indice de la cadena
BUCAR:          
    ld.bu r7, r3, r6        ;elemento de la cadena
    cmp r8, r7, r2          ;compara en r8 si r7 es igual al elem r2
    bb1 eq, r8, FINBU       ;si son iguales devuelve la posicion
    addu r6, r6, 1          ;incrementa la posicion
    cmp r8, r6, r5          ;comprueba si ha llegado al final
    bb1 ge, r8, FINBU       ;si ha llegado devuelve 'to'
    br BUCAR
FINBU:          
    or r29, r6, 0           ;devuelve la posicion
    POP(r1)
    jmp (r1)


;subrutina CoincidenCad
CoincidenCad:   
    PUSH(r1)
    ld r2, r30, 4           ;cadena 1
    ld r3, r30, 8           ;cadena 2
    xor r4, r4, r4          ;contador
BUCOIN:         
    ld.bu r5, r2, r4        ;caracter cadena 1
    ld.bu r6, r3, r4        ;caracter cadena 2
    cmp r7, r5, 0x00        ;si la primera cadena ha llegado al final
    bb1 eq, r7, FINCOI 
    cmp r7, r6, 0x00        ;si la segunda cadena ha llegado al final
    bb1 eq, r7, FINCOI
    cmp r7, r5, r6          ;comprobamos si son iguales
    bb1 ne, r7, FINCOI      ;si no son iguales va al final
    addu r4, r4, 1          ;incrementamos contador
    br BUCOIN
FINCOI:        
    or r29, r4, 0
    POP(r1)
    jmp(r1)


;subrutina BuscaMax
BuscaMax:       
    consPILA()
    subu r30, r30, 12 
    ld r2, r31, 8           ;ref
    ld r3, r31, 12          ;max
    ld r21, r31, 16         ;jj
    xor r10, r10, r10       ;marcador posicion p
    xor r11, r11, r11       ;longitud cadena coincidencia
    subu r22, r0, 1         ;valor -1
    st r22, r21, 0          ;lo guarda en jj

BUCMAX:        
    cmp r7, r10, r3
    bb1 eq, r7, FINMAX
    st r21, r31, -8         ;guardo jj
    st r11, r31, -4         ;guardo to 
    PUSH(r3)
    PUSH(r10)               ;p (r10) es el from
    PUSH(r2)                ;ref (r2) es la cadena
    ld.bu r4, r2, r3        ;ref[max]
    PUSH(r4)                ;ref[max] es caracter a buscar
    bsr BuscaCar
    POP(r4)
    POP(r2)
    POP(r10)
    POP(r3)
    ld r11, r31, -4         ;guardo to
    ld r21, r31, -8         ;jj
    cmp r7, r29, r3         ;si buscacar es igual a max
    bb1 eq, r7, FINMAX      ;no esta el caracter y se sale
    addu r10, r29, 0        ;avanza p hasta pos de buscacar
    st r2, r31, -12         ;guardo ref
    st r3, r31, -8          ;guardo max
    st r21, r31, -4         ;contador
    addu r4, r2, r3         ;ref[max]
    addu r5, r2, r10        ;copio ref(p)
    PUSH(r5)
    PUSH(r4)
    or r29,r0,r0
    bsr CoincidenCad
    POP(r4)
    POP(r5)
    ld r2, r31, -12         ;guardo ref
    ld r3, r31, -8          ;guardo max
    ld r21, r31, -4         ;contador
    cmp r7, r29, 255        ;si la longitud es 255 o mas
    bb1 ge, r7, ACT255
    cmp r7, r29, r11        ;comparo si es mayor el nuevo valor
    bb0 gt, r7, NEXT
    or r11, r29, 0          ;actualiza la longitud
    st r10, r21, 0          ;guarda p en jj?
NEXT:           
    addu r10, r10, 1        ;suma 1 a la posicion
    br BUCMAX
ACT255:
    addu r11, r0, 255       ;la nueva longitud es 255
    st r10, r21, 0          ;guarda la posicion
FINMAX:
    or r29, r11, 0          ;deja en r29 la longitud de la cadena mas larga
    destPILA()
    jmp(r1)   

;subrutina Comprime
Comprime:       
    consPILA()
    ld r2,r30,8             ;texto
    PUSH(r2)     
    bsr LongCad
    POP(r2)
    ld r3,r30,12            ;comprdo
    addu r4,r29,0           ;longitud texto comprimir
    divu r20,r29,4          ;r20=r29/4   
    mulu r20,r20,4          ;r20=r20*4
    subu r20,r29,r20    
    cmp r7,r20,0            ;com si esta en exceso 4
    bb1 eq,r7,COMP2
    addu r20,r20,4         
COMP2:
    subu r29,r29,r20    
    addu r29,r29,28         ;sumamos 28B adicionales a la pila
    subu r30,r30,r29        ;se crea marco de pila
    xor r10,r10,r10         ;cont texto parametro
    xor r11,r11,r11         ;cont texto pila
    xor r12,r12,r12
    addu r12,r0,5           ;cont mapa bits
    addu r13,r0,39          ;puntero bits en byte
COMP4:          
    ld.bu r23,r2,r10        ;r23<-texto+contador
    addu r10,r10,1          ;incrementa cont parametro
    st.b r23,r30,r11        ;r23->pila+contador pila
    addu r11,r11,1          ;incrementa cont pila    
    cmp r7,r10,8            ;comprueba si cont texto param es 8
    bb1 ne,r7,COMP4         ;si no es igual vuelve
    st.b r0,r3,r12          ;0 en mapa bits
COMP5:          
    cmp r7,r13,31           ;si ha acabado byte
    bb1 ne,r7,COMP5BUC
    addu r13,r0,39          ;rellena
    addu r12,r12,1          ;incrementa cont mapa
    st.b r0,r3,r12          ;0 en mapa bits
COMP5BUC:       
    st r11,r31,-8           ;se guarda con texto pila
    st r4,r31,-12           ;se guardan la longitud
    st r12,r31,-16          ;se guarda el cont mapa bits
    st r13,r31,-20          ;se guarda punt de bits en bytes
    st r3,r31,-24           ; se guarda comprdo
    subu r14,r31,4          ;cargamos jj en r14
    PUSH(r14)               ;jj
    PUSH(r10)               ;con texto parametro
    PUSH(r2)                ;texto
    bsr BuscaMax
    POP(r2)
    POP(r10)
    POP(r14)
    ld r11,r31,-8           ;carga cont texto pila
    ld r12,r31,-16          ;carga cont mapa de bits
    ld r13,r31,-20          ;carga punt de bits en bytes
    ld r3,r31,-24           ;cargar cargar comprdo
    addu r5,r29,0           ;guarda res (BuscaMax) en r5                                
    cmp r7,r5,4             ;comprueba si r5 es mayor igual que 4
    bb1 hs,r7,COMP5C        ;si lo es salta
    ld.bu r23,r2,r10        ;sino avanza un bit
    addu r10,r10,1
    st.b r23,r30,r11        ;lo copia en la pila
    addu r11,r11,1
    ld.bu r15,r3,r12        ;carga el ultimo bit del mapa
    clr r15,r15,r13         ;guarda 0 a partir del ultimo bit escrito 
    st.b r15,r3,r12         ;lo carga en el mapa de bits
    br ULTBIT               ;salta para comprobar si es el ultimo
COMP5C: 
    st.b r14,r30,r11        ;guarda la direccion obtenida en la pila
    addu r11,r11,1          ;avanza puntero
    extu r14,r14,0<8>  
    st.b r14,r30,r11        ;guarda la 2a mitad de la direccion
    addu r11,r11,1    
    st.b r5,r30,r11         ;guarda la longitud de la subcadena
    addu r11,r11,1   
    addu r10,r10,r5         ;avanza hasta el final de la subcadena
    ld.bu r15,r3,r12        ;guarda 1 a partir del ultimo bit escrito
    set r15,r15,r13    
    st.b r15,r3,r12   
ULTBIT:
    ld r4,r31,-12           ; carga el registro de la pila
    subu r13,r13,1          ;r13<-r13-1
    cmp r7,r4,r10           ;comprueba si se ha llegado al final del texto
    bb1 ne,r7,COMP5         ;si no ha llegado vuelve a comp5 
COMP6:          
    addu r12,r12,1          ;incrementa el contador
    addu r5,r12,r11         ;r5= cont mapa bits + cont pila
    addu r23,r12,0          ;r23<-r12
    addu r29,r5,0           ;r29<-r5
    xor r22,r22,r22
    st.b r4,r3,r22        
    extu r4,r4,0<8> 
    addu r22,r22,1      
    st.b r4,r3,r22
    addu r4,r0,1            ;guarda un 1 en cmprdo
    addu r22,r22,1
    st.b r4,r3,r22
    addu r22,r22,1   
    st.b r12,r3,r22         ;guarda la longitud del mapa de bits 
    addu r22,r22,1 
    extu r12,r12,0<8>  
    st.b r12,r3,r22    
    addu r22,r23,0          ;r22<-r23
    xor r24,r24,r24         ;contador para fincomp
FINCOMP:        
    ld.bu r23,r30,r24       ;se guarda lo copiado en la pila en cmprdo
    st.b r23,r3,r22
    addu r22,r22,1
    addu r24,r24,1
    cmp r7,r11,r24
     bb0 eq,r7,FINCOMP      ;hasta llegar al final
    st.b r0,r3,r22          ;se pone un ultimo 0
    ld r23,r31,-28
    add r30, r30, r23       ;se recupera el valor de la pila
    destPILA()
    jmp(r1)

Descomprime:
    consPILA()
	ld r2, r30, 8			;Puntero com
    ld r3, r30, 12			;Puntero desc
	xor r4, r4, r4			;Contador de com 
	xor r5, r5, r5 			;Contador de des
	xor r6, r6, r6			;Contador auxiliar
	ld.bu r10, r4, r2		;LongCadena sin com
	addu r4, r4, 1			;Avanza contador com
	ld.bu r8, r2, r4		;LongCadena con com
    mulu r8, r8, 256		;Pos byte1
    addu r4, r4, 1			;Avanza contador com
	addu r10, r10, r8		
	ld.bu r8, r2, r4		;M
    addu r4, r4, 1			;Avanza contador com
	mulu r8, r8, 8			;Bits sin comprimir	
	ld.bu r9, r2, r4		;Contador en inicio de texto
	addu r4, r4, 1			;Avanza contador com
	ld.bu r11, r2, r4		;Bytes inicio de texto
    addu r4, r4, 1			;Avanza contador com
	mulu r11, r11, 256		;Pos byte1 
	addu r9, r9, r11		;r9=r9+r11
HASTA8M:	
	ld.bu r12, r2, r9		;Primer caracter
    addu r9, r9, 1			;Avanza texto
    addu r6, r6, 1			;Avanza contador aux
	st.b r12, r3, r5		;Cargamos primer caracter en desc
	addu r5, r5, 1			;Avanza contador desc
	cmp r7, r6, r8
	bb1 eq, r7, BUDESC		;Si aux = 8 Avanza
	br HASTA8M				;Si es distinto de 8 vuelve a HASTA8M
BUDESC:  
	cmp r7, r6, 8
	bb1 ne, r7, SIGUE	    ;Si hemos copiado 8 bits avanza
	xor r6, r6, r6			;Contador = 0
	ld.bu r13, r2, r4		;Carga Byte
	addu r4, r4, 1			;Avanza contador com
	addu r14, r0, 39		;Puntero bits
SIGUE:	
	extu r11, r13, r14		;Carga Byte
	cmp r7, r11, 1
	bb1 eq, r7, BIT1		;Si es igual salta a BIT1
BIT0:		
	ld.bu r12, r2, r9		;Cargamos caracter
	st.b r12, r3, r5		
	subu r14, r14, 1	
	addu r9, r9, 1			;avanza al siguiente caracter
	addu r5, r5, 1			;avanza contador desc
	addu r6, r6, 1			;avanza auxiliar
	cmp r7, r5, r10
	bb1 eq, r7, FINDESC	    ;Si la longitud es igual hemos terminado
	br BUDESC		
BIT1:		
	ld.bu r15, r2, r9		;Cargamos Byte inicio
	addu r9, r9, 1			;Avanzamos al siguiente caracter
	ld.bu r16, r2, r9		;Byte siguiente
	mulu r16, r16, 256		;aux	
	addu r15, r15, r16		;Obtenemos desplazamiento
	addu r9, r9, 1			;Avanzamos al siguiente caracter
	ld.bu r16, r2, r9		;Byte siguiente
	addu r9, r9, 1			;Avanzamos al siguiente caracter
BUCBIT:	
	ld.bu r12, r3, r15		;Cargamos Byte
    addu r15, r15, 1		;Avanzamos posicion
	st.b r12, r3, r5		;Guardamos caracter
	addu r5, r5, 1			;Avanzamos desc
	subu r16, r16, 1		;Actualizamos aux
	cmp r7, r16, 0
	bb1 ne, r7, BUCBIT	    ;Si no es igual seguimos copiando
    addu r6, r6, 1			;Avanzamos contador
    subu r14, r14, 1		;r14=r14-1
FINDESC:
    cmp r7, r5, r10
	bb1 ne, r7, BUDESC		;Si no es igual vuelve a BUDESC
	st.b r0, r3, r5			; \0
	addu r29, r5, 0
    destPILA()		
	jmp (r1)
    
Verifica:	
    consPILA()
    ld	r2,r30,8            ;texto
    PUSH(r2)
    bsr LongCad
    POP(r2)
    addu r23,r29,0          ;Long texto original
    divu r4,r23,4           ;cociente
    mulu r4,r4,4            ;div
    subu r5,r4,r23          ;resto
    cmp r7,r5,0             ;si resto=0 saltamos a PILACOM
    bb1 eq, r7, PILACOM
    addu r4,r4,4            ;ajustamos
PILACOM:
    addu r23, r29, 7         ;r4+7
    divu r23, r23, 8          ;r4/8
    addu r23, r23, 4          ;r4+4 4=5(B cabecera)-1(B implicito)
    addu r23, r29, r23
    divu r6, r23, 4
    mulu r6, r4, 4
    subu r5, r23, r6
    cmp r7, r5, 0
    bb1 eq, r7, PILADES
    addu r6, r6, 4           ;ajuste
PILADES:
    addu r8, r4, r6
    addu r8, r8, 8
    subu r30, r30, r8       ;se crea marco de pila
    st r8, r31, -4
    st r6, r31, -8
    or r11, r30, 0
    ld r2, r31, 8
    PUSH(r11)
	PUSH(r2)
    bsr Comprime
    POP(r2)
	POP(r11)
    ld r6,r31,-8
    addu r12, r11, r6
	PUSH(r12)
	PUSH(r11)
	bsr Descomprime
	POP(r11)
	POP(r12)
    addu r15, r29, 0
    ld r13, r31, 16
    st r29, r13, 0
    ld r14, r31, 8
    PUSH(r12)
    PUSH(r15)
    PUSH(r14)
    bsr LongCad
    POP(r14)
    POP(r15)
    POP(r12)
    ld r13, r31, 12
    st r29, r13, 0
    cmp r7, r15, r29
    bb1 ne, r7, Caso1       ; si la longutid no es igual salta
    PUSH(r29)
    PUSH(r14)
    PUSH(r12)
    bsr CoincidenCad
    POP(r12)
    POP(r14)
    POP(r16)
    cmp r7, r29, r16
    bb1 ne, r7, Caso2
    or r29, r0, 0
    br fVerifica
Caso1:
    sub r29,r0,1           ;r29 = -1
    br fVerifica
Caso2:
    sub r29, r0, 2         ;r29 = -2
fVerifica:
    destPILA()
    jmp(r1)
