;DEFINICIÓN DE MACROS

    LEA:    MACRO(ra, eti) ;si es direccion
        or ra,r0,low(eti)
        or.u ra,ra,high(eti)
    ENDMACRO

    LOAD:   MACRO(ra, eti) ;si es valor
        LEA(ra,eti)
        ld ra,ra,0
    ENDMACRO

    PUSH:   MACRO(ra)
        subu r30,r30,4
        st ra,r30,0
    ENDMACRO

    POP:    MACRO(ra)
        ld ra,r30,0
        addu r30,r30,4
    ENDMACRO

    consPILA:   MACRO()
        PUSH(r1)
        PUSH(r31)
        or r31,r30,r30
    ENDMACRO

    destPILA:   MACRO()
        or r30,r31,r31
        POP(r31)
        POP(r1)
    ENDMACRO

     DBNZ:      MACRO(ra, eti)
        subu ra,ra,1
        cmp r7,ra,0
        bb1 ne,r7,eti
    ENDMACRO


org 3000
cadena1:    data "0azjdiedhbjbsd\0"
cadena2:    data "0bdiqwhdiokqjd\0"


org 0x0000010
;Subrutina LongCad
LongCad:        PUSH(r1)
                ld r2, r30, 4 ;cadena
                xor r5, r5, r5 ;contador
BULONG:         ld.bu r3, r2, r5 ;carga el caracter
                cmp r4, r3, 0x00 ;comprueba si ha llegado al final
                bb1 eq, r4, FINLO
                addu r5, r5, 1 ;incrementa el contador
                br BULONG
FINLO:          or r29, r5, 0 ;carga el resultado en r29
                POP(r1)
                jmp(r1)


;Subrutina BuscarCar
BuscaCar:       PUSH(r1)
                ld r2, r30, 4 ;caracter q se busca
                ld r3, r30, 8 ;cadena en la q se busca
                ld r4, r30, 12 ;posicion inicial
                ld r5, r30, 16 ;posicion final
                or r6, r4, 0 ;indice de la cadena
BUCAR:          ld.bu r7, r3, r6 ;elemento de la cadena
                cmp r8, r7, r2 ;compara en r8 si r7 es igual al elem r2
                bb1 eq, r8, FINBU ;si son iguales devuelve la posicion
                addu r6, r6, 1 ;incrementa la posicion
                cmp r8, r6, r5 ;comprueba si ha llegado al final
                ;comprobar lo de ge si funciona
                bb1 ge, r8, FINBU ;si ha llegado devuelve 'to'
                br BUCAR
FINBU:          or r29, r6, 0 ;devuelve la posicion
                POP(r1)
                jmp (r1)


;subrutina CoincidenCad
CoincidenCad:   PUSH(r1)
                ld r2, r30, 4 ;cadena 1
                ld r3, r30, 8 ;cadena 2
                xor r4, r4, r4 ;contador
BUCOIN:         ld.bu r5, r2, r4 ;caracter cadena 1
                ld.bu r6, r3, r4 ;caracter cadena 2
                cmp r7, r5, 0x00 ;si la primera cadena ha llegado al final
                bb1 eq, r7, FINCOI 
                cmp r7, r6, 0x00 ;si la segunda cadena ha llegado al final
                bb1 eq, r7, FINCOI
                cmp r7, r5, r6 ;comprobamos si son iguales
                bb1 ne, r7, FINCOI ;si no son iguales va al final
                addu r4, r4, 1 ;incrementamos contador
                br BUCOIN
FINCOI:         or r29, r4, 0
                POP(r1)
                jmp(r1)


;subrutina BuscaMax
BuscaMax:       consPILA()
                subu r30, r30, 12 
                ld r2, r31, 8 ;ref
                ld r3, r31, 12 ;max
                ld r21, r31, 16 ;jj
                xor r10, r10, r10 ;marcador posicion p
                xor r11, r11, r11 ;longitud cadena coincidencia
                subu r22, r0, 1 ;valor -1
                st r22, r21, 0 ;lo guarda en jj
BUCMAX:         st r21, r31, -8 ;guardo jj
                st r3, r31, -4;guardo to 
                PUSH(r10) ;p (r10) es el from
                PUSH(r2) ;ref (r2) es la cadena
                addu r4, r2, r3 ;ref[max]
                PUSH(r4) ;ref[max] es caracter a buscar
                bsr BuscaCar
                POP(r4)
                POP(r2)
                POP(r10)
                ld r3, r31, -4 ;guardo to
                ld r21, r31, -8;jj
                cmp r7, r29, r3 ;si buscacar es igual a max
                bb1 eq, r7, FINMAX ;no esta el caracter y se sale
                addu r10, r29, 0 ;avanza p hasta pos de buscacar
                st r2, r31, -12 ;guardo ref
                st r3, r31, -8 ;guardo max
                st r21, r31, -4;contador
                addu r5, r2, r10 ;copio ref(p)
                PUSH(r5)
                PUSH(r4)
                or r29,r0,r0
                bsr CoincidenCad
                POP(r4)
                POP(r5)
                ld r2, r31, -12 ;guardo ref
                ld r3, r31, -8 ;guardo max
                ld r21, r31, -4 ;contador
                cmp r7, r29, 255 ;si la longitud es 255 o mas
                bb1 ge, r7, ACT255
                cmp r7, r29, r11 ;comparo si es mayor el nuevo valor
                bb1 gt, r7, ACT
                addu r10, r10, 1    
                br BUCMAX
ACT:            or r11, r29, 0 ;actualiza la longitud
                st r10, r21, 0 ;guarda p en jj?
                addu r10, r10, 1        ;suma 1 a la posicion
                br BUCMAX
ACT255:         addu r11, r0, 255 ;la nueva longitud es 255
                st r10, r21, 0 ;guarda la posicion
FINMAX:         or r29, r11, 0 ;deja en r29 la longitud de la cadena mas larga
                destPILA()
                jmp(r1)    


;subrutina Comprime
Comprime:       consPILA()
                ld r2, r31, 8           ;texto
                ld r3,r31,12            ;comprdo
                PUSH(r2)     
                bsr LongCad
                POP(r2)
                addu r4,r29,0           ;longitud texto comprimir
                divu r20,r4,4            ;divide el resultado entre 4
                mulu r20,r20,4           ;lo multiplica por 4
                subu r20,r20,r4          ;resta r29-r29/4*4
                addu r20,r20,4           ;sino añade a r5 4
                addu r20,r20,24         ;reserva de pila
                subu r30,r30,r20        ;se crea marco de pila
                xor r10,r10,r10         ;cont texto parametro
                xor r11,r11,r11         ;cont texto pila
                addu r12,r0,5           ;puntero mapa bits
                addu r13,r0,39          ;puntero bits en byte
COMP4:          ld.bu r20,r2,r10   ;r11<-texto+contador
                addu r10,r10,1      ;incrementa cont pila
                st.b r20,r30,r11   ;r11->pila+contador
                addu r11,r11,1      ;incrementa cont texto    
                cmp r7,r10,8       ;comprueba si cont texto es 8
                bb1 ne,r7,COMP4  ;si no es igual vuelve
                st.b r0,r3,r12          ;0 en mapa bits
COMP5:          cmp r7,r13,31           ;si ha acabado byte
                bb1 ne,r7,COMP5BUC
                addu r13,r13,8          ;rellena
                addu r12,r12,1          ;incrementa cont mapa
                st.b r0,r3,r12          ;0 en mapa bits
COMP5BUC:       st r4,r31,-16           ;se guardan los parametros
                ;st r13,r31,-20
                ;st r12,r31,-16
                st r11,r31,-12
                st r3,r31,-8
                subu r14,r31,4
                PUSH(r14)
                PUSH(r10)
                PUSH(r2)
                bsr BuscaMax
                POP(r2)
                POP(r10)
                POP(r14)
                ld r3,r31,-8
                ld r11,r31,-12
                ld r4,r31,-16
                ld r14,r14,0
                ld r5,r29,0                                 
                cmp r7,r5,4
                bb1 hs,r7,COMP5C        ;si es menor que 4->comp5b 
                ld.bu r20,r2,r10
                addu r10,r10,1
                st.b r20,r30,r11
                addu r11,r11,1
                ld.bu r20,r3,r12
                clr r20,r20,r13
                st.b r20,r3,r12
                br ULTBIT
COMP5C:         st.b r14,r30,11
                addu r11,r11,1
                extu r14,r14,0<8> ;extrae de r12 todos los bits cn desp 8
                st.b r14,r30,r11   ;r30+r8<-r12
                addu r11,r11,1      ;r8<-r8+1
                st.b r5,r30,r11   ;r30+r8<-r29
                addu r11,r11,1      ;r8<-r8+1
                addu r10,r10,r5    ;r9<-r9+r29
                ld.bu r20,r3,r12  ;r13<-r3+r10
                set r20,r20,r13    ;pone a 1 los bits de r13
                st.b r20,r3,r12   ;r3+r10<-r13                
ULTBIT:         subu r13,r13,1
                cmp r7,r4,r10
                bb1 ne,r7,COMP5
COMP6:          addu r12,r12,1        ;incrementa puntero
                addu r29,r12,r11       ;r29<-puntero+contpila
                addu r21,r12,0        ;r15<-puntero
                st.b r4,r3,0        ;r3+0<-r4
                extu r4,r4,0<8>       ;hace un desplazamiento en r4 de 8 hacia la derecha
                st.b r4,r3,1        ;guarda otro bit
                addu r22,r0,1         ;r17=1
                st.b r22,r3,2       ;r3+2<-1
                st.b r12,r3,3       ;r3+3<-puntero
                extu r12,r12,0<8>     ;hace un desplzamiento en r10 de 8 a la derecha
                st.b r12,r3,4       ;r3+4<-r10
                ld r22,r22,r22         ;r17=0                 
FINCOMP:        ld.bu r20,r30,r22
                addu r22,r22,1
                st.b r20,r3,r21
                addu r21,r21,1
                cmp r7,r11,r22
                bb1 ne,r7,FINCOMP
                st.b r0,r3,r21
                destPILA()
                jmp(r1)


Descomprime:  PUSH(r1)
              ld r2,r30,4           ;lugarcom
              ld r3,r30,8           ;lugardes
              ld.bu r4,r2,r0        ;longitud texto
              ld.bu r20,r2,1        ;r20<- 2bit de com
              mulu r20,r20,256      ;r20<-2obit*256
              addu r4,r4,r20        ;r4<-r4+r20*256 long total
              addu r8,r0,8          ;r8<-8
              ld.bu r20,r2,3        ;long r20<-dist hasta caracteres    
              ld.bu r21,r2,4        ;r28<-lugarcom+4 (2ocaracter)
              mulu r21,r21,256      ;r28<- 2ocaracter*256
              addu r20,r20,r21      ;r27<- r27 + 2ocar*256
              addu r10,r20,0        ;r10<- r20 (inicio caracteres)
              xor r11,r11,11        ;cont des
              addu r12,r0,5         ;cont mapa bits
              addu r14,r0,39        ;cont bits
HASTA8M:      ld.bu r20,r2,r10      ;r11 cargar caracteres
              addu r10,r10,1        ;aumenta puntero com
              st.b r20,r3,r11       ;r3+r5(pos desc)<-r11
              addu r11,r11,1        ;aumenta puntero desc
              DBNZ(r8,HASTA8M)      ;decrementa r8 hasta que sea igual
BUDESC:       cmp r21,r11,r4         ;si r5 == final
              bb1 eq,r21,FINDESC     ;si no es igual vuelve al bucle
              cmp r21,r14,31        ;si r13 == 31
              bb1 ne,r21,DESCBYTE   ;si es igual a 31 salta 
              addu r14,r14,8        ;r8<-39
              ld.bu r13,r2,r12      ;r13 ahora sirve para cargar bytes del mapa de bits
              addu r12,r12,1        ;incrementa r12
DESCBYTE:     extu r22,r13,r14      ;extrae 1 bit con desp del mapa
              subu r14,r14,1        ;decrementa r8
              cmp r21,r22,1          ;compara si el bit del mapa es 0
              bb1 eq,r21,BIT1        ;si lo es salta a bit 0
              ld.bu r20,r2,r10      ;r11<-carga el bit de la cadena com
              addu r10,r10,1        ;incrementa puntero com
              st.b r20,r3,r11       ;lo guarda en la cadena des
              addu r11,r11,1        ;incrementa puntero des
              br BUDESC      
BIT1:         ld.bu r15,r2,r10      ;posicion
              addu r10,r10,1        ;incrementa posicion
              ld.bu r20,r2,r10      ;r27<-carga el siguiente caracter
              addu r10,r10,1        ;incrementa contador
              st.b r15,r23,r0       ;carga 1a parte
              st.b r20,r23,1        ;carga 2a parte
              ld r15,r23,0          ;carga long en r15
              ld.bu r16,r2,r10      ;longitud cadena ref
              addu r10,r10,1        ;incrementa contador
              addu r16,r16,r15      ;fin cadena<-poscadena + long      
COP_BIT1:     ld.bu r20,r3,r15      ;r11<- desc+pos
              addu r15,r15,1        ;incrementa contador cadena
              st.b r20,r3,r11       ;des+punt<- bit
              addu r11,r11,1        ;incrementa contador
              cmp r21,r15,r16       ;compara cn fin cadena
              bb1 ne,r21,COP_BIT1     ;si no es igual vuelve
              br BUDESC
FINDESC:      st.b r0,r3,r11        ;sino guarda un 0 al final de desc
              addu r29,r11,0        ;guarda en r29 el cont de car copiados
              POP(r1)
              jmp(r1)

Verifica:
    jmp(r1)

    
